// Pedestal Slider Extension for Will Myers Slider Pro
class PedestalSlider {
    constructor(element, sections) {
        this.container = element;
        this.sections = sections || [];
        this.scale = parseInt(element.dataset.effectPedestalScale) || 100;
        
        // Build the pedestal slider from the sections
        this.buildPedestalSlider();
        
        this.slider = element.querySelector('.pedestal-slider');
        this.track = element.querySelector('.pedestal-track');
        this.slides = Array.from(element.querySelectorAll('.pedestal-slide'));
        this.indicators = Array.from(element.querySelectorAll('.indicator'));
        this.prevBtn = element.querySelector('#prevBtn');
        this.nextBtn = element.querySelector('#nextBtn');
        
        this.currentIndex = 0;
        this.totalSlides = this.slides.length;
        
        this.init();
    }
    
    buildPedestalSlider() {
        // Calculate scale factor (0-100 becomes 0.0-1.0)
        const scaleFactor = this.scale / 100;
        
        // If no sections provided, create demo content
        if (this.sections.length === 0) {
            this.createDemoSlider();
            return;
        }
        
        // Create slides from actual sections
        const sliderHTML = `
            <div class="pedestal-slider">
                <div class="pedestal-track">
                    ${this.sections.map((section, index) => this.createSlideFromSection(section, index, scaleFactor)).join('')}
                </div>
            </div>
            <div class="pedestal-nav">
                <button class="nav-btn" id="prevBtn">â€¹</button>
                <button class="nav-btn" id="nextBtn">â€º</button>
            </div>
            <div class="pedestal-indicators">
                ${this.sections.map((_, index) => `<div class="indicator ${index === 0 ? 'active' : ''}" data-slide="${index}"></div>`).join('')}
            </div>
        `;
        
        this.container.innerHTML = sliderHTML;
    }
    
    createSlideFromSection(section, index, scaleFactor) {
        // Clone the section content safely
        const sectionClone = section.cloneNode(true);
        
        // Remove potentially problematic elements
        sectionClone.querySelectorAll('script, style, link').forEach(el => el.remove());
        
        // Get the content
        const sectionHTML = sectionClone.innerHTML;
        
        return `
            <div class="pedestal-slide ${index === 0 ? 'active' : this.getInitialPosition(index, this.sections.length)}">
                <div class="slide-content full-section" style="transform: scale(${scaleFactor}); transform-origin: center center;">
                    ${sectionHTML}
                </div>
            </div>
        `;
    }
    
    createDemoSlider() {
        // Calculate scale factor (0-100 becomes 0.0-1.0)
        const scaleFactor = this.scale / 100;
        
        // Create demo slides with sample content
        const demoSlides = [
            {
                title: "Welcome",
                content: "This is your pedestal slider in action! Each slide can contain any content from your sections.",
                icon: "ðŸŽ¯",
                color: "#4F46E5"
            },
            {
                title: "Features",
                content: "Beautiful 3D transitions, touch support, keyboard navigation, and fully responsive design.",
                icon: "âœ¨",
                color: "#059669"
            },
            {
                title: "Customizable",
                content: "Adjust the scale, speed, and styling to match your brand. Works with any Squarespace content.",
                icon: "ðŸŽ¨",
                color: "#DC2626"
            }
        ];
        
        const sliderHTML = `
            <div class="pedestal-slider">
                <div class="pedestal-track">
                    ${demoSlides.map((slide, index) => `
                        <div class="pedestal-slide ${index === 0 ? 'active' : this.getInitialPosition(index, demoSlides.length)}">
                            <div class="slide-content text-only" style="transform: scale(${scaleFactor}); transform-origin: center center; background: linear-gradient(135deg, ${slide.color}20, ${slide.color}10); padding: 30px; text-align: center;">
                                <div class="slide-icon" style="color: ${slide.color};">${slide.icon}</div>
                                <div class="slide-title" style="color: ${slide.color};">${slide.title}</div>
                                <div class="slide-description">${slide.content}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
            <div class="pedestal-nav">
                <button class="nav-btn" id="prevBtn">â€¹</button>
                <button class="nav-btn" id="nextBtn">â€º</button>
            </div>
            <div class="pedestal-indicators">
                ${demoSlides.map((_, index) => `<div class="indicator ${index === 0 ? 'active' : ''}" data-slide="${index}"></div>`).join('')}
            </div>
        `;
        
        this.container.innerHTML = sliderHTML;
    }
    
    getInitialPosition(index, totalSlides) {
        if (index === 1) return 'next';
        if (index === 2) return 'far-next';
        if (index === totalSlides - 1) return 'prev';
        if (index === totalSlides - 2) return 'far-prev';
        return '';
    }
    
    init() {
        this.updateSlidePositions();
        this.bindEvents();
        this.startAutoplay();
    }
    
    bindEvents() {
        // Navigation buttons
        this.prevBtn?.addEventListener('click', () => this.prev());
        this.nextBtn?.addEventListener('click', () => this.next());
        
        // Indicators
        this.indicators.forEach((indicator, index) => {
            indicator.addEventListener('click', () => this.goToSlide(index));
        });
        
        // Slide clicks
        this.slides.forEach((slide, index) => {
            slide.addEventListener('click', () => {
                if (index !== this.currentIndex) {
                    this.goToSlide(index);
                }
            });
        });
        
        // Touch/swipe support
        let startX = 0;
        let isDragging = false;
        
        this.slider.addEventListener('touchstart', (e) => {
            startX = e.touches[0].clientX;
            isDragging = true;
        });
        
        this.slider.addEventListener('touchend', (e) => {
            if (!isDragging) return;
            isDragging = false;
            
            const endX = e.changedTouches[0].clientX;
            const diffX = startX - endX;
            
            if (Math.abs(diffX) > 50) {
                if (diffX > 0) {
                    this.next();
                } else {
                    this.prev();
                }
            }
        });
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') this.prev();
            if (e.key === 'ArrowRight') this.next();
        });
        
        // Pause autoplay on hover
        this.slider.addEventListener('mouseenter', () => this.pauseAutoplay());
        this.slider.addEventListener('mouseleave', () => this.startAutoplay());
    }
    
    updateSlidePositions() {
        this.slides.forEach((slide, index) => {
            slide.classList.remove('active', 'prev', 'next', 'far-prev', 'far-next');
            
            const position = this.getSlidePosition(index);
            if (position) {
                slide.classList.add(position);
            }
        });
        
        // Update indicators
        this.indicators.forEach((indicator, index) => {
            indicator.classList.toggle('active', index === this.currentIndex);
        });
    }
    
    getSlidePosition(index) {
        const diff = index - this.currentIndex;
        
        if (diff === 0) return 'active';
        if (diff === 1 || (diff === -(this.totalSlides - 1))) return 'next';
        if (diff === -1 || (diff === this.totalSlides - 1)) return 'prev';
        if (diff === 2 || (diff === -(this.totalSlides - 2))) return 'far-next';
        if (diff === -2 || (diff === this.totalSlides - 2)) return 'far-prev';
        
        return null;
    }
    
    next() {
        this.currentIndex = (this.currentIndex + 1) % this.totalSlides;
        this.updateSlidePositions();
    }
    
    prev() {
        this.currentIndex = (this.currentIndex - 1 + this.totalSlides) % this.totalSlides;
        this.updateSlidePositions();
    }
    
    goToSlide(index) {
        this.currentIndex = index;
        this.updateSlidePositions();
    }
    
    startAutoplay() {
        this.pauseAutoplay();
        this.autoplayInterval = setInterval(() => {
            this.next();
        }, 4000);
    }
    
    pauseAutoplay() {
        if (this.autoplayInterval) {
            clearInterval(this.autoplayInterval);
            this.autoplayInterval = null;
        }
    }
}

// Integration with Will Myers Slider Pro

// Override Will Myers initialization to inject pedestal effect
function interceptWillMyersInit() {
    // Store original initialization if it exists
    const originalInit = window.wmSliderInit;
    
    // Create our enhanced initialization
    window.wmSliderInit = function() {
        // Call original Will Myers init first if it exists
        if (originalInit && typeof originalInit === 'function') {
            originalInit.apply(this, arguments);
        }
        
        // Now handle pedestal effects
        setTimeout(() => {
            initPedestalSliders();
        }, 100);
    };
}

function initPedestalSliders() {
    // Find all Will Myers slider containers
    const sliderContainers = document.querySelectorAll('[data-wm-plugin="section-slider"]');
    
    sliderContainers.forEach(container => {
        const effect = container.dataset.effect;
        
        if (effect === 'pedestal' && !container.classList.contains('pedestal-processed')) {
            container.classList.add('pedestal-processed');
            
            // Find the sections that Will Myers would normally process
            const sections = findWillMyersSections(container);
            
            if (sections.length > 0) {
                // Replace the container content with pedestal slider
                const pedestalContainer = document.createElement('div');
                pedestalContainer.className = 'pedestal-container';
                
                // Initialize pedestal slider
                new PedestalSlider(pedestalContainer, sections);
                
                // Replace the Will Myers container
                container.parentNode.replaceChild(pedestalContainer, container);
                
                // Hide the original sections
                sections.forEach(section => {
                    section.style.display = 'none';
                });
            } else {
                // No sections found, create demo
                new PedestalSlider(container, []);
            }
        }
    });
}

function findWillMyersSections(container) {
    const sections = [];
    const slidesCount = parseInt(container.dataset.slides) || 3;
    
    // Find the parent section containing the code block
    let parentSection = container.closest('section[data-section-id], .page-section');
    
    if (!parentSection) {
        // Try to find by looking for code block parent
        const codeBlock = container.closest('.sqs-block-code, .code-block, .sqs-block-html');
        if (codeBlock) {
            parentSection = codeBlock.closest('section[data-section-id], .page-section');
        }
    }
    
    if (parentSection) {
        // Get all sections on the page
        const allSections = Array.from(document.querySelectorAll('section[data-section-id], .page-section'));
        const parentIndex = allSections.indexOf(parentSection);
        
        // Get the next sections after the parent
        for (let i = parentIndex + 1; i < allSections.length && sections.length < slidesCount; i++) {
            const section = allSections[i];
            // Make sure the section has content
            if (section.textContent.trim().length > 0) {
                sections.push(section);
            }
        }
    }
    
    // Fallback: get any sections with content
    if (sections.length === 0) {
        const allSections = document.querySelectorAll('section[data-section-id], .page-section, .sqs-block');
        for (let i = 0; i < allSections.length && sections.length < slidesCount; i++) {
            const section = allSections[i];
            if (section.textContent.trim().length > 50) { // Has substantial content
                sections.push(section);
            }
        }
    }
    
    console.log('Found sections for pedestal:', sections);
    return sections;
}

// Initialize immediately and also intercept Will Myers
document.addEventListener('DOMContentLoaded', () => {
    interceptWillMyersInit();
    
    // Try immediate initialization
    setTimeout(() => {
        initPedestalSliders();
    }, 100);
    
    // Also try after a longer delay in case Will Myers loads later
    setTimeout(() => {
        initPedestalSliders();
    }, 1000);
});

// Handle dynamic content loading
if (window.MutationObserver) {
    const observer = new MutationObserver(() => {
        setTimeout(initPedestalSliders, 100);
    });
    
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });
}
